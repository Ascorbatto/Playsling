package youtube

import (
	utils "Conversify/Server/Controllers/Utils"
	models "Conversify/Server/Models"
	"encoding/json"
	"log"
	"net/http"
	"net/url"
)

func GetSearchInfo(w http.ResponseWriter, r *http.Request, songs models.Song) string {
	search_name := songs.Name
	for _, author := range songs.Author {
		search_name = search_name + " " + author
	}

	query := utils.EncodeString(url.QueryEscape(search_name))

	body, err := utils.GETRequest(utils.YoutubeSearch+query, Token.AccessToken, nil)
	utils.ErrorManager(utils.ReadResponseError, err)

	var results models.SearchVideos
	err = json.Unmarshal(body, &results)
	utils.ErrorManager(utils.UnmarshalJSONError, err)

	for _, item := range results.Items {
		artist := utils.CleanAuthorString(item.Snippet.ChannelTitle)
		title := utils.CleanString(item.Snippet.Title)

		if len(artist) > 0 {
			if utils.LcsComparation(title, songs.Name) {
				log.Printf("Track '%s' found by autogenerated content.", songs.Name)
				return item.Id.VideoId
			}
		}
	}

	for _, item := range results.Items {
		artist := utils.CleanAuthorString(item.Snippet.ChannelTitle)
		title := utils.CleanString(item.Snippet.Title)

		if len(artist) == 0 {
			if utils.LcsComparation(title, songs.Name) {
				video := getVideoInfo(item.Id.VideoId)
				if utils.CompareDuration(songs.Duration, utils.ISO8601ToSec(video.Items[0].ContentDetails.Duration), 10) {
					log.Printf("Track '%s' found by duration.", songs.Name)
					return item.Id.VideoId
				}
			}
		}
	}

	log.Printf("Track '%s' not found.", songs.Name)
	return ""
}
